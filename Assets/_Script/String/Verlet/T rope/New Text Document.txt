using UnityEngine;

using System.Collections.Generic;

using System.Linq;

using System;

/// <summary>

/// Node dữ liệu cho từng điểm của dây.

/// Mỗi node tự lưu vị trí hiện tại, vị trí cũ, và cờ isPinned (cố định hay không).

/// </summary>

[System.Serializable]

public struct RopeNode4

{

    public Vector2 position;

    public Vector2 oldPosition;

    public bool isPinned;

    public RopeNode4(Vector2 pos, bool pinned = false)

    {

        position = pos;

        oldPosition = pos;

        isPinned = pinned;

    }

    public Vector2 Velocity => position - oldPosition;

}

/// <summary>

/// Dây mô phỏng bằng Verlet integration.

/// Không dùng Rigidbody thật, chỉ mô phỏng vị trí.

/// Có thể cắt, spawn lại các đoạn.

/// </summary>

public class VerletRope7 : MonoBehaviour, IRopeDataProvider

{

    [Header("Profile (Optional)")]

    public RopeProfile profile;

    [Header("Rope Parameters")]

    public int nodeCount = 20;

    [HideInInspector] public float segmentLength = 0.2f;

    [HideInInspector] public float gravity = 9.81f;

    [HideInInspector, Range(0.8f, 0.9999f)] public float damping = 0.995f;

    [HideInInspector] public int constraintIterations = 6;

    [HideInInspector] public float slack = 1.1f;

    [HideInInspector] public float recoilStrength = 1.5f;

    [Header("Simulation")]

    public bool simulate = true;

    [SerializeField] private float maxStretchDistance = 0.9f;   // Ngưỡng đứt do giãn

    [SerializeField] private float velocityThreshold = 0.02f;    // Ngưỡng tốc độ giãn

    [SerializeField] private float cutThreshold = 0.95f; // dây đạt 95% chiều dài tối đa thì bắt đầu xét

    [SerializeField] private float weakRatio = 0.45f;            // Tỷ lệ node yếu (giữa các node tự do)

    private bool hasCut = false;                                 // Cờ ngăn cắt lặp

    public bool isStartDetached = false;

    public bool isEndDetached = false;

    [SerializeField] private float retractSpeed = 5f;

    [SerializeField] private float releaseSpeed = 5f;

    [SerializeField] private KeyCode retractKey = KeyCode.W;

    [SerializeField] private KeyCode releaseKey = KeyCode.S;

    int index = 0;

    private int retractIndex = 1;

    [SerializeField] private int releaseIndex = 1;

    private bool isRetracting = false;

    private bool isReleasing = false;

    private float retractProgress = 0f;

    private float releaseProgress = 0f;

    [Header("Visual")]

    public Transform startPoint;

    public Transform endPoint;

    [SerializeField] private bool isBlinking = false;

    private Color originalColor = Color.magenta;

    private bool hasOriginalColor = false;

    private Color blinkColorA = Color.magenta;

    private Color blinkColorB = Color.white;

    private float blinkSpeed = 0.5f;

    private float blinkTimer = 0f;

    public bool shouldBlink = false;

    public List<RopeNode4> nodes = new();

    public List<int> freeNodes = new List<int>();

    [SerializeField] private RopeRender ropeRenderPrefab;

    private RopeRender ropeRenderInstance;

    int IRopeDataProvider.NodeCount => nodeCount;

    IReadOnlyList<RopeNode4> IRopeDataProvider.Nodes => nodes;

    bool IRopeDataProvider.ShouldBlink => shouldBlink;

    event Action IRopeDataProvider.OnNodesReady
    {
        add => _onNodesReady += value;
        remove => _onNodesReady -= value;
    }

    private void NotifyNodesReady()
    {
        _onNodesReady?.Invoke();
    }

    private void Awake()

    {

        // Chỉ setup khi đã có profile hoàn chỉnh

        if (profile == null || profile.physics == null || profile.render == null)

            return;

        ApplyProfile();

        SetupRendererFromProfile();

    }

    void Start()

    {

        if (profile.physics

        != null)

            ApplyProfile();

        // Nếu rope đã có node (spawn runtime) => không cần InitializeRope

        if (nodes != null && nodes.Count > 0)

        {

            nodeCount = nodes.Count;

            simulate = true;

        }

        else if (startPoint && endPoint)

        {

            //InitializeRope(startPoint.position, endPoint.position, slack);

            InitializeRope_CompressStretch(startPoint.position, endPoint.position);

        }

        else

        {

            Debug.LogWarning($"[{name}] Rope missing startPoint or endPoint reference!");

        }

    }

    public void InitializeRuntime(RopeProfile sourceProfile,

    List<RopeNode4> runtimeNodes,

    Transform start,

    Transform end)

    {

        profile = sourceProfile;

        ApplyProfile();

        SetupRendererFromProfile();

        nodes = new List<RopeNode4>(runtimeNodes);

        nodeCount = nodes.Count;

        startPoint = start;

        endPoint = end;

        simulate = true;

    }

    private void SetupRendererFromProfile()

    {

        if (profile.physics == null)

        {

            Debug.LogError($"[{name}] Missing RopePhysicsProfile", this);

            enabled = false;

            return;

        }

        if (profile.render == null)

        {

            Debug.LogError($"[{name}] RopeProfile missing render prefab", this);

            enabled = false;

            return;

        }

        GameObject go = Instantiate(profile.render.renderPrefab, transform);

        if (!go.TryGetComponent(out ropeRenderInstance))

        {

            Debug.LogError(

            $"[{name}] Render prefab does not contain RopeRender",

            go

            );

            Destroy(go);

            enabled = false;

            return;

        }

        ropeRenderInstance.Bind(this);

    }

#if UNITY_EDITOR

    void OnValidate()

    {

        if (profile == null || profile.physics == null)

            return;

        ApplyProfile();

    }

#endif

    public void ApplyProfile()

    {

        gravity = profile.physics.gravity;

        damping = profile.physics.damping;

        segmentLength = profile.physics.segmentLength;

        constraintIterations = profile.physics.constraintIterations;

        slack = profile.physics.slackFactor;

    }

    // -------------------------------------------------------------------------

    // Initialization

    // -------------------------------------------------------------------------

    public void InitializeRope(Vector2 start, Vector2 end, float slackFactor = 1f)

    {

        nodes.Clear();

        float ropeLength = Vector2.Distance(start, end) * slackFactor;

        nodeCount = Mathf.Max(2, (int)(ropeLength / segmentLength + 1));

        Vector2 dir = (end - start).normalized;

        for (int i = 0; i < nodeCount; i++)

        {

            Vector2 pos = start + dir * segmentLength * i;

            nodes.Add(new RopeNode4(pos));

        }

        var n = nodes[0];

        if (startPoint && !isStartDetached)

        {

            n.position = startPoint.position;

            n.oldPosition = startPoint.position;

            n.isPinned = true;

            nodes[0] = n;

        }

        else

        {

            n.isPinned = false;

            nodes[0] = n;

        }

        var nE = nodes[nodeCount - 1];

        if (endPoint && !isEndDetached)

        {

            nE.position = endPoint.position;

            nE.oldPosition = endPoint.position;

            nE.isPinned = true;

            nodes[nodeCount - 1] = nE;

        }

        else

        {

            nE.isPinned = false;

            nodes[0] = nE;

        }

        NotifyNodesReady();

        //AttachRenderer();

    }

    // -------------------------------------------------------------------------

    // Simulation

    // -------------------------------------------------------------------------

    void FixedUpdate()

    {

        if (!simulate || nodes.Count == 0) return;

        SimulateVerlet(Time.fixedDeltaTime);

        ApplyConstraints();

        if (isRetracting)

            ApplyRetract(Time.fixedDeltaTime);

        else if (isReleasing)

            ApplyRelease(Time.fixedDeltaTime);

    }

    void SimulateVerlet(float dt)

    {

        Vector2 gravityVec = new Vector2(0, -gravity);

        for (int i = 0; i < nodeCount; i++)

        {

            if (nodes[i].isPinned) continue;

            RopeNode4 n = nodes[i];

            Vector2 pos = n.position;

            Vector2 old = n.oldPosition;

            Vector2 velocity = (pos - old) * damping;

            n.oldPosition = pos;

            n.position = pos + velocity + gravityVec * dt * dt;

            nodes[i] = n;

        }

        ForceUpdateAnchors();

    }

    void ApplyConstraints()

    {

        for (int iter = 0; iter < constraintIterations; iter++)

        {

            for (int i = 0; i < nodeCount - 1; i++)

            {

                RopeNode4 n1 = nodes[i];

                RopeNode4 n2 = nodes[i + 1];



                Vector2 delta = n2.position - n1.position;

                float dist = delta.magnitude;

                if (dist == 0f) continue;



                float diff = (dist - segmentLength) / dist;

                Vector2 correction = delta * diff * 0.5f;



                if (!n1.isPinned) n1.position += correction;

                if (!n2.isPinned) n2.position -= correction;



                nodes[i] = n1;

                nodes[i + 1] = n2;

            }

        }

        ForceUpdateAnchors();

    }

    void ForceUpdateAnchors()

    {

        if (startPoint)

            nodes[0] = new RopeNode4(startPoint.position, true);

        if (endPoint)

            nodes[nodeCount - 1] = new RopeNode4(endPoint.position, true);

    }

    // -------------------------------------------------------------------------

    // Cutting System

    // -------------------------------------------------------------------------

    public void CutAtNode(int index)

    {

        if (index <= 0 || index >= nodeCount - 1)

            return;

        // 1. Tách danh sách node

        List<RopeNode4> left = new List<RopeNode4>(nodes.GetRange(0, index + 1));

        List<RopeNode4> right = new List<RopeNode4>(nodes.GetRange(index, nodeCount - index));

        // 2. Đồng bộ vị trí cắt

        Vector2 cutPos = nodes[index].position;

        var lastLeft = left[left.Count - 1];

        lastLeft.position = cutPos;

        left[left.Count - 1] = lastLeft;

        var firstRight = right[0];

        firstRight.position = cutPos;

        right[0] = firstRight;

        // 3. Recoil

        Vector2 dir = (nodes[Mathf.Min(index + 1, nodeCount - 1)].position -

        nodes[Mathf.Max(index - 1, 0)].position).normalized;

        ApplyRecoil(left, -dir * recoilStrength);

        ApplyRecoil(right, dir * recoilStrength);

        // 4. Tạo 2 dây mới

        SpawnRopePiece(left, "LeftPiece", startPoint);

        SpawnRopePiece(right, "RightPiece", null, endPoint);

        // 5. Xóa dây gốc

        Destroy(gameObject);

    }

    void ApplyRecoil(List<RopeNode4> list, Vector2 recoil)

    {

        for (int i = 0; i < list.Count; i++)

        {

            float falloff = (float)i / list.Count;

            RopeNode4 n = list[i];

            n.position += recoil * (1f - falloff) * 0.1f;

            list[i] = n;

        }

    }

    // -------------------------------------------------------------------------

    // Debug / Utility

    // -------------------------------------------------------------------------

    void Update()

    {

        // Giữ phím W để thu dây

        if (Input.GetKey(retractKey))

        {

            isRetracting = true;

            isReleasing = false;

        }

        else if (Input.GetKey(releaseKey))

        {

            isReleasing = true;

            isRetracting = false;

        }

        else

        {

            isRetracting = false;

            isReleasing = false;

        }

        // Cho phép thay đổi tốc độ động (ví dụ: Shift = nhanh gấp đôi)

        float speedModifier = Input.GetKey(KeyCode.LeftShift) ? 2f : 1f;

        retractSpeed = Mathf.Clamp(retractSpeed * speedModifier, 0.5f, 10f);

        releaseSpeed = Mathf.Clamp(releaseSpeed * speedModifier, 0.5f, 10f);

        //if (Input.GetKeyDown(KeyCode.C))

        //    CutAtNode(nodeCount / 2);

        shouldBlink = GetCurrentRopeLength() >= GetCurrentMaxLength() / 1.25f;

    }

    public void StartRetract()

    {

        if (isReleasing) isReleasing = false;

        isRetracting = true;

    }

    public void StopRetract()

    {

        isRetracting = false;

    }

    public void StartRelease()

    {

        if (isRetracting) isRetracting = false;

        isReleasing = true;

    }

    public void StopRelease()

    {

        isReleasing = false;

    }

    private void ApplyRetract(float delta)

    {

        if (!isRetracting) return;

        index = FindLastPinnedCloseToAnchor(0.01f);

        Debug.Log("index " + index);

        retractIndex = ResolveRetractIndex(index);

        if (retractIndex < 1)

        {

            isRetracting = false;

            return;

        }

        RopeNode4 n = nodes[retractIndex];

        RopeNode4 prev = nodes[retractIndex - 1];

        Vector2 nextPos;

        if (retractIndex == nodeCount - 1)

        {

            nextPos = nodes[releaseIndex].position + Vector2.down;

        }

        else

        {

            nextPos = nodes[retractIndex + 1].position;

        }

        retractProgress = Vector2.Distance(n.position, prev.position) - retractSpeed * delta;

        Debug.Log("retractProgress " + retractProgress);

        n.isPinned = true;

        if (retractProgress <= 0f)

        {

            n.position = GeometryUtils.GetPointOnLine(prev.position, nextPos, 0f);

        }

        else

        {

            n.position = GeometryUtils.GetPointOnLine(prev.position, nextPos, retractProgress);

        }

        n.oldPosition = n.position;

        nodes[retractIndex] = n;

    }

    private void ApplyRelease(float delta)

    {

        Debug.Log("index r " + index);

        if (!isReleasing) return;

        index = FindLastPinnedCloseToAnchor(0.01f);

        Debug.Log("index r " + index);

        releaseIndex = ResolveReleaseIndex(index);

        if (releaseIndex <= 0)

        {

            isReleasing = false;

            return;

        }

        RopeNode4 n = nodes[releaseIndex];

        RopeNode4 prev = nodes[releaseIndex - 1];

        Vector2 nextPos;

        if (releaseIndex == nodeCount - 1)

        {

            nextPos = nodes[releaseIndex].position + Vector2.down;

        }

        else

        {

            nextPos = nodes[releaseIndex + 1].position;

        }

        // Tích lũy tiến trình nhả

        releaseProgress = Vector2.Distance(n.position, prev.position) + releaseSpeed * delta;

        Debug.Log("releaseProgress " + releaseProgress);

        Debug.Log("Distance " + Vector2.Distance(n.position, nextPos));

        if (releaseProgress >= segmentLength)

        {

            n.position = GeometryUtils.GetPointOnLine(prev.position, nextPos, segmentLength);

            n.isPinned = false;

        }

        else

        {

            n.position = GeometryUtils.GetPointOnLine(prev.position, nextPos, releaseProgress);

        }

        if (releaseIndex == nodeCount - 1)

        {

            n.isPinned = true;

        }

        n.oldPosition = n.position;

        nodes[releaseIndex] = n;

    }

    int FindLastPinnedCloseToAnchor(float threshold)

    {

        Vector2 anchorPos = nodes[0].position;

        for (int i = nodes.Count - 2; i >= 0; i--)

        {

            if (!nodes[i].isPinned)

                continue;

            float dist = Vector2.Distance(nodes[i].position, anchorPos);

            if (dist <= threshold)

                return i;

        }

        return -1;

    }

    int ResolveReleaseIndex(int index)

    {

        if (index <= 0 || index > nodes.Count - 1)

            return -1;

        if (index == nodes.Count - 1)

            return index;

        if (nodes[index + 1].isPinned)

        {

            return index + 1;

        }

        else

        {

            return index;

        }

    }

    int ResolveRetractIndex(int index)

    {

        if (index < 0 || index >= nodes.Count - 1)

            return -1;

        return index + 1;

    }

    public void InitializeRope_CompressStretch(Vector3 start, Vector3 end, int fixedNodeCount = 35)

    {

        nodes.Clear();

        nodeCount = Mathf.Max(2, fixedNodeCount);

        float idealTotalLength = segmentLength * (nodeCount - 1);   // độ dài lý tưởng

        float actualDist = Vector2.Distance(start, end);            // khoảng cách thực tế

        float scale = actualDist / idealTotalLength;                // hệ số nén/giãn

        Vector3 dir = (end - start).normalized;

        for (int i = 0; i < nodeCount; i++)

        {

            // vị trí spawn bị nén/giãn tạm thời

            float idealOffset = segmentLength * i;

            Vector3 pos = start + dir * (idealOffset * scale);

            nodes.Add(new RopeNode4(pos));

        }

        // Pin hai đầu nếu có anchor

        if (startPoint) nodes[0] = new RopeNode4(startPoint.position, true);

        if (endPoint) nodes[nodeCount - 1] = new RopeNode4(endPoint.position, true);

        NotifyNodesReady();

        //AttachRenderer();

    }

    public float GetCurrentRopeLength()

    {

        if (nodes == null || nodes.Count < 2)

            return 0f;

        float totalLength = 0f;

        for (int i = 0; i < nodes.Count - 1; i++)

        {

            totalLength += Vector2.Distance(nodes[i].position, nodes[i + 1].position);

        }

        return totalLength;

    }

    public float GetLengthAtStretch(float stretchPercent)

    {

        float ideal = ComputeIdealLength();

        return ideal * (1f + stretchPercent);

    }

    public float GetCurrentMaxLength()

    {

        return ComputeIdealLength() * profile.physics.maxStretchFactor;

    }

    public float ComputeIdealLength()

    {

        float sum = 0f;

        for (int i = 0; i < nodes.Count - 1; i++)

        {

            RopeNode4 a = nodes[i];

            RopeNode4 b = nodes[i + 1];

            if (a.isPinned && b.isPinned)

            {

                // Nếu cả hai pinned → lấy độ dài thật ở runtime      

                sum += Vector2.Distance(a.position, b.position);

            }

            else

            {

                // Nếu không → dùng segmentLength cố định      

                sum += segmentLength;

            }

        }

        return sum;

    }

    public event Action _onNodesReady;

    public void FinalizeBuild()
    {

        NotifyNodesReady();

    }

    void SpawnRopePiece(

    List<RopeNode4> nodeList,

    string nameSuffix,

    Transform startAnchor = null,

    Transform endAnchor = null)

    {

        GameObject go = new GameObject("RopePiece_" + nameSuffix);

        var newRope = go.AddComponent<VerletRope7>();

        newRope.InitializeRuntime(

        profile,

        nodeList,

        startAnchor,

        endAnchor

        );

    }

    public static implicit operator VerletRope7(VerletRopeRefactor v)

    {

        throw new NotImplementedException();

    }

}